<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta charset="UTF-8">
  <style type="text/css">
  body{background-color: rgb(43,119,143);}
  </style>
  <title>§3．2  栈的应用举例</title>
</head>

<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
  <table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
    <tr> 
      <td>
        <div align="center">
          <table width="75%" border="1" cellpadding="10" cellspacing="3" bordercolor="#CCCCCC">
            <tr> 
              <td height="38" valign="top" bordercolor="#FFFFFF" bgcolor="#EEEEEE"> 
                <div align="center"> 
                  <p class="css"><strong>数 据 结 构 与 算 法</strong></p>
                </div></td>
              </tr>
              <tr> 
                <td height="166" valign="top" bordercolor="#FFFFFF" bgcolor="#FFFFFF" class="css">
                  <h1>第三章     栈和队列</h1>
                  <h2>§3．2  栈的应用举例</h2>
                  由于栈的“后进先出”特点，在很多实际问题中都利用栈做一个辅助的数据结构来进行求解，下面通过几个例子进行说明。
                  <h3>3.2.1 数制转换</h3>
                  将十进制数N转换为r进制的数，其转换方法利用辗转相除法：以N=3456，r=8为例转换方法如下： <br>       
                  N         N / 8 （整除）        N  % 8（求余） <br>     
                  3467          433                   3                  低 <br>     
                  433           54                    1 <br>
                  54            6                     6 <br>     
                  6             0                     6                  高 <br>
                  我们看到所转换的8进制数按底位到高位的顺序产生的，而通常的输出是从高位到低位的，恰好与计算过程相反，因此转换过程中每得到一位8进制数则进栈保存，转换完毕后依次出栈则正好是转换结果。 v算法思想如下：当N&gt;0时重复1，2 <br>
                  若 N≠0，则将N % r 压入栈s中 ，执行2;若N=0，将栈s的内容依次出栈，算法结束。 <br>
                  用N / r 代替 N<br>
                  算法如下： <br>  
                  typedef  int datatype;                  #define L  10 <br>
                  void conversion(int N，int r)             void conversion(int N，int r) <br>
                  { SeqStack  s;                         {  int  <br>
                  s[L],top;      /*定义一个顺序栈*/ <br>
                  datetype   x;                           int   x; <br>
                  Init_SeqStack(&amp;s);                           top =-1;   /*初始化栈*/ <br>
                  while ( N )                             while ( N ) <br>   
                  { Push_SeqStack ( &amp;s ，N % r );         {  s[++top]=N%r;        /*余数入栈 */<br>
                  N=N / r ;                         N=N / r ;   /* 商作为被除数继续 */ <br>   
                }                                  } <br>
                while  ( Empty_SeqStack(&amp; s ) )          while (top!=-1)<br>  
                {  Pop_SeqStack (&amp;s ，&amp;x ) ;          { x=s[top--]; <br>     
                printf ( “ %d ”，x ) ;                 printf(“%d”,x); <br>  
              }                                   } <br>
            }                                   } <br>
            算法3.1(a)                              算法3.1(b)<br>
            算法3.1(a)是将对栈的操作抽象为模块调用，使问题的层次更加清楚。而算法3.1(b)中的直接用int向量S和int 变量top作为一个栈来使用，往往初学者将栈视为一个很复杂的东西，不知道如何使用，通过这个例子可以消除栈的“神秘”，当应用程序中需要一个与数据保存时相反顺序使用数据时，就要想到栈。通常用顺序栈较多，因为很便利。 <br>
            在后面的例子中，为了在算法中表现出问题的层次，有关栈的操作调用了的相关函数，如象算法3.1(a)那样，对余数的入栈操作：Push_SeqStack ( &amp;s ，N % r );  因为是用c语言描述，第一个参数是栈的地址才能对栈进行加工。<br>
            <h3>3.2.2 括号匹配的检验</h3>
            假设在一个算术表达式中，可以包含三种括号：圆括号“（”和“）”，方括号“[”和“]”和花括号“{”和“}”，并且这三种括号可以按任意的次序嵌套使用。比如，...[...{...}...[...]...]...[...]...(...)..。现在需要设计一个算法，用来检验在输入的算术表达式中所使用括号的合法性。<br>
            算术表达式中各种括号的使用规则为：出现左括号，必有相应的右括号与之匹配，并且每对括号之间可以嵌套，但不能出现交叉情况。我们可以利用一个栈结构保存每个出现的左括号，当遇到右括号时，从栈中弹出左括号，检验匹配情况。在检验过程中，若遇到以下几种情况之一，就可以得出括号不匹配的结论：<br>
            （1）当遇到某一个右括号时，栈已空，说明到目前为止，右括号多于左括号； <br>
            （2）从栈中弹出的左括号与当前检验的右括号类型不同，说明出现了括号交叉情况； <br>
            （3）算术表达式输入完毕，但栈中还有没有匹配的左括号，说明左括号多于右括号。<br>
            下面是解决这个问题的完整算法。 <br>            
            typedef char StackEntry; <br>            
            int Check( ) <br>            
            { <br>             
            STACK S;        //定义栈结构S <br>             
            char ch; <br>
            InitStack(&amp;S);      //初始化栈S <br>
            while ((ch=getchar())!=’\n’) {   <br>
            //以字符序列的形式输入表达式 <br>  
            switch (ch) { <br>   
            case (ch==‘(’||ch== ‘[’||ch== ‘{’): Push(&amp;S,ch);break;  //遇左括号入栈 <br>   
            //在遇到右括号时，分别检测匹配情况</p>
            <h3>3.2.3 行编辑程序</h3>
            功能：接受用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出错，所以，若在编辑程序中，“每接受一个字符即存入用户数据区”的做法显然不是恰当的。较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出错时及时改正。例如，当用户发现刚刚键入的一个字符是错的时，可补进一个“#”，表示前一个字符无效；如果发现当前的行内差错较多或难以补救，则输入一个“@“，表示当前行中的字符无效。<br>
            算法思想：设立这个缓冲区为一个栈结构，每当从终端接受了一个字符后，先作如下判别：如果它既不是退行符也不是退格符，则将该字符压入栈顶；如果是一个退格符，则从栈顶删除一个字符；如果它是一个退行符，则将字符清为空栈。
            <h3>3.2.4 迷宫的求解 </h3>
            问题： 这是实验心理学中的一个经典问题，心理学家把一只老鼠从一个无顶盖的大盒子的入口处赶进迷宫。迷宫中设置很多隔壁，对前进方向形成了多处障碍，心理学家在迷宫的唯一出口处放置了一块奶酪，吸引老鼠在迷宫中寻找通路以到达出口。<br>
            求解思想：回溯法是一种不断试探且及时纠正错误的搜索方法。下面的求解过程采用回溯法。从入口出发，按某一方向向前探索，若能走通（未走过的），即某处可以到达，则到达新点，否则试探下一方向 ; 若所有的方向均没有通路，则沿原路返回前一点，换下一个方向再继续试探，直到所有可能的通路都探索到，或找到一条通路，或无路可走又返回到入口点。 <br>
            在求解过程中，为了保证在到达某一点后不能向前继续行走（无路）时，能正确返回前一点以便继续从下一个方向向前试探，则需要用一个栈保存所能够到达的每一点的下标及从该点前进的方向。<br>
            需要解决的四个问题： <br>
            1．表示迷宫的数据结构： <br>
            设迷宫为m行n列，利用maze[m][n]来表示一个迷宫，maze[i][j]=0或1; 其中：0表示通路，1表示不通，当从某点向下试探时，中间点有8个方向可以试探，（见图3.4）而四个角点有3个方向，其它边缘点有5个方向，为使问题简单化我们用maze[m+2][n+2]来表示迷宫，而迷宫的四周的值全部为1。这样做使问题简单了，每个点的试探方向全部为8，不用再判断当前点的试探方向有几个，同时与迷宫周围是墙壁这一实际问题相一致。<br>
            3．栈的设计<br>
            当到达了某点而无路可走时需返回前一点，再从前一点开始向下一个方向继续试探。因此，压入栈中的不仅是顺序到达的各点的坐标，而且还要有从前一点到达本点的方向。<br>
            栈中元素是一个由行、列、方向组成的三元组，栈元素的设计如下： <br>
            typedef struct <br>
            {int x , y , d ;/* 横纵坐标及方向*/ <br>
          }datatype ; v栈的定义仍然为：  SeqStack  s ; <br>
          如何防止重复到达某点，以避免发生死循环： <br>
          一种方法是另外设置一个标志数组mark[m][n]，它的所有元素都初始化为0，一旦到达了某一点 ( i , j )之后，使mark[i][j] 置1，下次再试探这个位置时就不能再走了。另一种方法是当到达某点（i , j）后使maze[i][j] 置 -1，以便区别未到达过的点，同样也能起到防止走重复点的目的，本书采用后者方法，算法结束前可恢复原迷宫。<br>
          迷宫求解算法思想如下： <br>
          栈初始化; <br>
          将入口点坐标及到达该点的方向（设为－1）入栈 <br>
          while (栈不空) <br>
          { 栈顶元素＝＞（x , y , d） <br>
          出栈 ; <br>
          求出下一个要试探的方向d++ ; <br>      
          while  （还有剩余试探方向时）<br>
          {  if  （d方向可走） <br>
          则 { （x , y , d）入栈 ; <br>      
          求新点坐标  (i, j ) ; <br>
          将新点（i , j）切换为当前点（x , y） ; <br> 
          if  ( (x ,y)= =(m,n) ) 结束 ; <br>       
          else 重置 d=0 ; <br>    
        } <br>                   
        else  d++ ; <br>
      } <br>  
    } <br>
    算法如下： <br>
    int  path(maze，move) <br>         
    int maze[m][n] ; <br>
    item move[8] ; <br>        
    { SeqStack  s ; <br>          
    datetype  temp ; <br>          
    int x, y, d, i, j ;<br>
    temp.x=1 ;  temp.y=1 ;  temp.d=-1 ; <br>          
    Push-_SeqStack (s，temp) ; <br>
    |          
    while (! Empty_SeqStack (s ) ) <br>             
    {  Pop_SeqStack (s,&amp;temp) ; vx=temp.x ;  y=temp.y ;  d=temp.d+1 ; <br>
    while  (d&lt;8)<br>
    {  i=x+move[d].x ;   j=y+move[d].y ; <br>
    if  ( maze[i][j]= =0 )<br> 
    {  temp={x, y, d} ; <br>    
    Push_SeqStack ( s, temp ) ; <br>    
    x=i ;  y=j ;  maze[x][y]= -1 ; <br>    
    if  (x==m&amp;&amp;y= =n)  return 1 ; /*迷宫有路*/ <br>    
    else  d=0 ; <br>
  } <br> 
  else  d++ ; <br>
} /*while (d&lt;8)*/ <br>        
}  /*while */<br>    
return  0 ;/*迷宫无路*/ <br> 
} <br>
栈中保存的就是一条迷宫的通路
<h3>3.2.5 表达式求值 </h3>
表达式求值是程序设计语言编译中一个最基本的问题。它的实现也是需要栈的加入。下面的算法是由算符优先法对表达式求值。 <br>
算术四则运算规则为： <br>
（1）先乘除、后加减 <br>
（2）从左算到右 <br>
（3）先括号内，后括号外<br>
任何一个表达式是由操作数、运算符和界定符组成的，我们称为单词，我们将运算符和界限符统称算符，它们构成的集合命名为OP。根据上述运算规则，在运算的每一步中，任意两个相继出现的算符θ1和θ2之间的优先关系至多是下面3种关系之一： <br>
θ1&lt;θ2   θ1的优先权低于θ2 <br>
θ1=θ2   θ1的优先权等于θ2<br>
θ1&gt;θ2   θ1的优先权高于θ2 <br>
P53 表3.1  定义了算符间的优先关系</p>
<p>算法思想： <br>
  为实现算符优先算法，可以使用两个工作栈，一个OPTR，用以寄存运算器，另一个OPND，用以寄存操作数或运算结果。 <br>
  （1）首先，置操作数栈为空栈，表达式起始符“#”为运算栈的栈底元素； <br>
  （2）依次读入表达式中每个字符，若是操作数则进OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（即OPTR栈的栈顶元素和当前读入的字符均为“#”）。<br>
  P53  算法3.4描述了求值过程。</p></td>
</tr>
</table>
</div></td>
</tr>
</table>
</body>
</html>
