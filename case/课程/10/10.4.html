
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta charset="UTF-8">
  <style type="text/css">
    body{background-color: rgb(43,119,143);}
  </style>
  <title>§10.4归并排序</title>
</head>

<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td>
      <div align="center">
        <table width="75%" border="1" cellpadding="10" cellspacing="3" bordercolor="#CCCCCC">
          <tr> 
            <td height="38" valign="top" bordercolor="#FFFFFF" bgcolor="#EEEEEE"> 
              <div align="center"> 
                <p class="css"><strong>数 据 结 构 与 算 法</strong></p>
              </div>
            </td>
          </tr>
          <tr> 
            <td height="166" valign="top" bordercolor="#FFFFFF" bgcolor="#FFFFFF" class="css">
            <h1>第十章  排序</h1>
            <p><h2>§10.4归并排序 </h2>
              二路归并排序的基本操作是将两个有序表合并为一个有序表。 <br>    
              设r[u…t]由两个有序子表r[u…v-1]和r[v…t]组成，两个子表长度分别为v-u、t-v+1。合并方法为：<br> 
              ⑴ i=u；j=v；k=u；      //置两个子表的起始下标及辅助数组的起始下标 <br>
              ⑵ 若i&gt;v 或 j&gt;t，转⑷     //其中一个子表已合并完，比较选取结束<br>
              ⑶ //选取r[i]和r[j]关键码较小的存入辅助数组rf<br>
              如果r[i].key&lt;r[j].key，rf[k]=r[i]； i++； k++； 转⑵ <br>    
              否则，rf[k]=r[j]； j++； k++； 转⑵ <br> 
              ⑷ //将尚未处理完的子表中元素存入rf <br>
              如果i&lt;v，将r[i…v-1]存入rf[k…t]    //前一子表非空 <br>
              如果j&lt;=t，将r[i…v]存入rf[k…t]    //后一子表非空 <br>
              ⑸ 合并结束。<br>
              <h4>【算法1】 </h4>
              void    Merge(ElemType *r，ElemType *rf，int u，int v，int t) <br>
              { <br>
              for(i=u，j=v，k=u；i&lt;v&amp;&amp;j&lt;=t；k++) <br>
              { if(r[i].key&lt;r[j].key) <br>
              { rf[k]=r[i]；i++；} <br> 
              else <br>
              { rf[k]=r[j]；j++；}<br>
              } if(i&lt;v) rf[k…t]=r[i…v-1]； <br>
              if(j&lt;=t) rf[k…t]=r[j…t]；<br>
              }<br>
            <h3>二路归并的迭代算法</h3>
            一个元素的表总是有序的，所以n个元素的待排序列，每个元素可看成一个有序子表，对子表亮亮合并生成{n/2}个子表，所得子表除最后一个子表长度可能为1外，其余子表的长度均为2，再进行两两合并，直到生成n个元素按关键有序的表。
            <h3>二路归并的递归算法</h3>
            <h4>【算法2】 </h4>
            void MSort(ElemType *p，ElemType *p1，int s，int t) <br>
            { /*将p[s…t]归并排序为p1[s…t]*/ <br> 
            if(s==t) p1[s]=p[s] <br> 
            else <br>
            { m=(s+t)/2； /*平分*p表*/ <br>
            MSort(p，p2，s，m)； /*递归地将p[s…m]归并为有序的p2[s…m]*/ <br>
            MSort(p，p2，m+1，t)； /*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/ <br>
            Merge(p2，p1，s，m+1，t)； /*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/ <br> 
            }<br>
            }<br>
            void MergeSort(S_TBL *p) <br>
            { /*对顺序表*p作归并排序*/ <br> 
            MSort(p-&gt;elem，p-&gt;elem，1，p-&gt;length)；<br>
            【效率分析】 <br>
            需要一个与表等长的辅助元素数组空间，所以空间复杂度为O(n)。<br>
            对n个元素的表，将这n个元素看作叶结点，若将两两归并生成的子表看作它们的父结点，则归并过程对应由叶向根生成一棵二叉树的过程。所以归并趟数约等于二叉树的高度-1，即log2n，每趟归并需移动记录n次，故时间复杂度为O(nlog2n)。<br>
            </p>
            </td>
          </tr>
        </table>
      </div></td>
  </tr>
</table>
</body>
</html>
