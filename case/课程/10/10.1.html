
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta charset="UTF-8">
  <style type="text/css">
    body{background-color: rgb(43,119,143);}
  </style>
  <title>§10.1插入排序</title>
</head>

<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
  <table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
    <tr> 
      <td>
        <div align="center">
          <table width="75%" border="1" cellpadding="10" cellspacing="3" bordercolor="#CCCCCC">
            <tr> 
              <td height="38" valign="top" bordercolor="#FFFFFF" bgcolor="#EEEEEE"> 
                <div align="center"> 
                  <p class="css"><strong>数 据 结 构 与 算 法</strong></p>
                </div>
              </td>
            </tr>
            <tr> 
              <td height="166" valign="top" bordercolor="#FFFFFF" bgcolor="#FFFFFF" class="css"> 
              <h1>第10章   排 序</h1>
              <p><h2>§10.1插入排序</h2>
              <h3>10.1.1直接插入排序</h3>
              直接插入排序是一种简单的排序方法，它的基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的记录增1的有序表<br>  
              直接插入排序方法：仅有一个记录的表总是有序的，因此，对n个记录的表，可从第二个记录开始直到第n个记录，逐个向有序表中进行插入操作，从而得到n个记录按关键码有序的表。<br>
              <h3>10.1.2其他排序</h3>
              1.▲:折半插入排序 <br>
              直接插入排序的基本操作是向有序表中插入一个记录，插入位置的确定通过对有序表中记录按关键码逐个比较得到的。平均情况下总比较次数约为n2/4。既然是在有序表中确定插入位置，可以不断二分有序表来确定插入位置，即一次比较，通过待插入记录与有序表居中的记录按关键码比较，将有序表一分为二，下次比较在其中一个有序子表中进行，将子表又一分为二。这样继续下去，直到要比较的子表中只有一个记录时，比较一次便确定了插入位置。 <br>
              二分判定有序表插入位置方法：<br>
              ① low=1；high=j-1；r[0]=r[j]；    // 有序表长度为j-1，第j个记录为待插入记录 <br>
              //设置有序表区间，待插入记录送辅助单元 <br>
              ② 若low&gt;high，得到插入位置，转⑤ <br>
              ③ low≤high，m=(low+high)/2；     // 取表的中点，并将表一分为二，确定待插入区间*/ <br>
              ④ 若r[0].key&lt;r[m].key，high=m-1； //插入位置在低半区 <br>
              否则，low=m+1；                 // 插入位置在高半区<br>   
              转② <br>
              ⑤ high+1即为待插入位置，从j-1到high+1的记录，逐个后移，r[high+1]=r[0]；放置待插入记录。<br>
              2.▲:路插入排序 <br>
              是在折半插入排序的基础上再次改进,其目的是减少排序过程中移动记录的次数,但为此需要n个记录的辅助空间. <br>
              在2路插入排序中,移动记录的次数约为n2/8 <br>
              3.▲:表插入排序 <br>  
              直接插入排序、折半插入排序均要大量移动记录，时间开销大。若要不移动记录完成排序，需要改变存储结构，进行表插入排序。所谓表插入排序，就是通过链接指针，按关键码的大小，实现从小到大的链接过程，为此需增设一个指针项。操作方法与直接插入排序类似，所不同的是直接插入排序要移动记录，而表插入排序是修改链接指针。用静态链表来说明。<br>
              #define  SIZE  200<br>
              typedef  struct{ <br>
              ElemType  elem；      /*元素类型*/ <br>
              int       next；      /*指针项*/ <br>           
              }NodeType；           /*表结点类型*/ <br>
              typedef    struct{ <br>           
              NodeType  r[SIZE]；   /*静态链表*/ <br>           
              int       length；    /*表长度*/ <br>           
              }L_TBL；              /*静态链表类型*/ <br>
              假设数据元素已存储在链表中，且0号单元作为头结点，不移动记录而只是改变链指针域，将记录按关键码建为一个有序链表。首先，设置空的循环链表，即头结点指针域置0，并在头结点数据域中存放比所有记录关键码都大的整数。接下来，逐个结点向链表中插入即可。<br>
              表插入排序得到一个有序的链表，查找则只能进行顺序查找，而不能进行随机查找，如折半查找。为此，还需要对记录进行重排。 <br>    
              重排记录方法：按链表顺序扫描各结点，将第i个结点中的数据元素调整到数组的第i个分量数据域。因为第i个结点可能是数组的第j个分量，数据元素调整仅需将两个数组分量中数据元素交换即可，但为了能对所有数据元素进行正常调整，指针域也需处理。<br>
              <h3>10.1.3希尔排序(Shell’s Sort)</h3>
              希尔排序又称缩小增量排序，是1959年由D.L.Shell提出来的，较前述几种插入排序方法有较大的改进。<br>
              直接插入排序算法简单，在n值较小时，效率比较高，在n值很大时，若序列按关键码基本有序，效率依然较高，其时间效率可提高到O(n)。希尔排序即是从这两点出发，给出插入排序的改进方法。<br>
              希尔排序方法： <br>  
              1. ▲:选择一个步长序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>
              2.▲: 按步长序列个数k，对序列进行k趟排序； <br>
              3.▲: 每趟排序，根据对应的步长ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅步长因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>
              </p>
              </td>
            </tr>
          </table>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
